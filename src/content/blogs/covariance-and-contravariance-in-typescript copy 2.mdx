---
id: '7df351d1-fe2c-4948-8b56-bec2bbec5f50'
author: Asaf Naory
title: Understanding Covariance and Contravariance in TypeScript
tags: ['typescript', 'javascript']
image: /public/covariance-and-contravariance-in-typescript.png
authorImage: /public/AsafNaory.jpg
---

TypeScript, a typed superset of JavaScript, has transformed the way developers build large-scale applications. One of its more nuanced features is the concept of covariance and contravariance, which come into play in type compatibility and inheritance. Grasping these concepts can greatly enhance your ability to write robust and error-free code.

What is Covariance?
Covariance deals with how TypeScript handles the assignment of types in a subclass-superclass relationship. It is most easily understood in the context of return types and array types.

Return Type Covariance
In TypeScript, a method in a subclass can return a type that is a subtype of the return type in the superclass. This is known as return type covariance.

```typescript
    class Animal {
        makeSound(): AnimalSound {
            // ...
        }
    }

    class Dog extends Animal {
        makeSound(): Bark {
            // ...
        }
    }
```
In the above example, Bark is a subtype of AnimalSound. TypeScript allows this because every Bark instance is also an AnimalSound instance, maintaining type safety.

Array Type Covariance
TypeScript treats arrays as covariant. This means an array of a subtype can be assigned to an array of a supertype.

Copy code
```typescript
let dogs: Dog[] = [new Dog(), new Dog()];
let animals: Animal[] = dogs;
```
Here, dogs (an array of Dog objects) can be assigned to animals (an array of Animal objects) because Dog is a subtype of Animal.

What is Contravariance?
Contravariance is the opposite of covariance and applies to function argument types in TypeScript.

Argument Type Contravariance
In TypeScript, a method in a subclass can accept arguments that are supertypes of the ones in the superclass method.

```typescript
class Animal {
    makeSound(): AnimalSound {
        // ...
    }
}

class Dog extends Animal {
    makeSound(): Bark {
        // ...
    }
}

class Wolf extends Animal {
    // ...
}
```

In this example, the Dog class's setPartner method can accept either Dog or Wolf, both of which are supertypes of Dog in the context of the Animal class.

Why Does It Matter?
Understanding covariance and contravariance helps in designing APIs and libraries that are both type-safe and flexible. It allows you to predict how your types will behave in inheritance hierarchies and ensures that your code adheres to the Liskov Substitution Principle, a key concept in object-oriented programming.

Conclusion
Covariance and contravariance might seem abstract at first, but they are fundamental to mastering TypeScript’s type system. By understanding these concepts, you can leverage TypeScript’s full potential, leading to more robust and maintainable code. Keep exploring and experimenting with these concepts to deepen your understanding and application in real-world scenarios.