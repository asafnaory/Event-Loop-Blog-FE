---
id: '683d7f38-dcb5-4259-aceb-3493bd85f9d5'
author: Asaf Naory
title: "React Server Component vs Astro Components"
tags: ['react', 'next', 'astro']
date: February 27 2024
image: '../assets/astro-blog.png'
authorImage: '../assets/AsafNaory2.png'
---

React Server Components (RSC) are the, (not so) new hype in React, I guess you know them if you are here, but for those of you who do not
 [NextJs docs](https://nextjs.org/docs/app/building-your-application/rendering/server-components)

RSC are written using React (of course), and the data that is streamed to the client, 
it is not HTML, but is something called *React Server Component Payload* that represents the component, 
the placeholders for where [Client Components](https://nextjs.org/docs/app/building-your-application/rendering/client-components) should be rendered and any props passed from the Server.

For example:

```
3:I[7151,[],""]
4:I[7173,[],""]
0:["3C9wdBOqSjd8Hs2tA4aLQ",[[["",{"children":["route1",{"children":["__PAGE__",{}]}]},"$undefined","$undefined",true],["",{"children":["route1",{"children":["__PAGE__",{},[["$L1","$L2"],null]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","route1","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__className_aaf875","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}]}]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/b24e6923321a8480.css","precedence":"next","crossOrigin":""}]],"$L5"]]]]
6:"$Sreact.suspense"
8:"$Sreact.fragment"
2:[["$","h1",null,{"children":"Some Static Template Start!!"}],["$","$6",null,{"fallback":["$","h1",null,{"children":"Loading..."}],"children":"$L7"}],["$","h1",null,{"children":"Some Static Template End!!"}]]
9:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Create Next App"}],["$","meta","3",{"name":"description","content":"Generated by create next app"}],["$","link","4",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","meta","5",{"name":"next-size-adjust"}]]
5:["$","$8","O56IjCjabCi9_67Qnm6U3",{"children":"$9"}]
1:null
7:P

```


On the other hand Astro components are very simple. They are HTML-only templating components with no client-side runtime. 
As it says on the astro website, it is just good old HTML, with some extra features.


In this article I will compare RSC with Astro Components to see if there any advantage to either one. 


### React server component are not SSR (?) but Astro components are
People always say RSC and SSR are not the same, but they accually quit are. 
If you look at the  Nextjs Docs under the benefits of server rendering (under react server components) you will accually find all the [benefits of SSR](https://nextjs.org/docs/app/building-your-application/rendering/server-components#benefits-of-server-rendering)


For example : Data Fetching  *Server Components allow you to move data fetching to the server, closer to your data source* - this is also true for SSR. there is no special benefit for 
server components doing that. 

The only diffrences is *Streaming* which we will talk about soon. 


But if RSC have the same benefits as SSR, why people say these are two different concepts? 

Well, that is probably because that in the context of *metaframeworks* (like NextJs or Remix) RSC and SSR are different:

1. SSR happens only in the initial page loading and RSC are running on the server during the whole app life time
2. SSR returns HTML and RSC return the *React Server Component Payload*

But if you think about it, SSR or server side rendering, has noting to do with initial page load or HTML. 
If you redner the code on the server, you SSR. Seems like RSC and SSR try to achive the same goal, so why do we need to models? 

Well that is due to the fact that NextJs and Remix are really SPAs and astro in an MPA.

In Asto every navigation returns a new HTML, so it can leverage the SSR for initial page load from NextJs to all its pages.


In NextJs when navigating, there is no new HTML, so there sould be a different way to get server rendered data that will be injected to the already created React Vdom (hence RSC)


So we undersand that RSC and Astro components are trying to achive the samge things, now for my case

### Astro components use clearer model and less error prone
Asro components are exactly the model I wanted! why? 
Astro component have the same benefits as RSC - for example: 
1. Data Fetching - Astro components have an area where you can data fetch your data, and use it in the HTML template
2. Bundle Sizes - Astro components ship Zero javasctipt to the client. 

But the model is cleaer, for three reasons:

#### 1. HTML, Only HTML and nothing but HTML

Astro components ship HTML to the client and not *React Server Component Payload*. In my opinion this is simpler model, since the web works with HTML.

Look at the react server component payload above, it is not easy to understand what is going on there. 
If something unexpectable is displayed in the browser, can you tell what is the problem?
In Astro components you can, since it is just HTML.
As I mentioned above this model keeps being true after navigations as well, since Astro is MPA and not SPA.
In Astro every time we go to a new route we get new HTML, so the SSR model is still valid. 

Now you maybe think what about hard refresh between routes? This is not to purpose of this blog post, but take a look at astro [view transitions](https://docs.astro.build/en/guides/view-transitions/).

#### 2. Two Different Models for Two Different Environemnts
One of the benefits of RSC is the fact they are *React Components*. This fact make it easyer for developers to undersand the new syntax since this is the same coding model,
and it feels simmiar to the client component they know already (like Lego breaks). But this can be also drawback. When using the same model it easyer to make mistakes. take for example this component: 

```typescript
    const displayHello = () => {
        <h1>Hello user!</h1>
    }
```
which will display very simple string on the screen. Lets say for example that after a few weeks there is a request to change it to display the `user name`.
The developer can make this change:

```typescript
    'use client'
    // imports  ...

    const displayHello = () => {
        const [userName, setUserName ] = useState()
        useEffect(()=>{
            async function setUserToState() {
                const userName = await getUserNameFromServer() // http request...
                setUserName(userName)
            }
            await setUserToState()
        });

        <h1>Hello {userName}!</h1>
    }
```
This might look like a lot of code to you, but for someone who does not know the new model, this might be a quick solution. I have seen a lot of bad code in my life, 
I totaly think it can happen. Now this component if forever be a client component for no good reason. 


The fact that astro has a different model for components that run on the server and cannot be configuerd to run on the client is a benefit in my opinion.
First, the model is very easy - 


for example: 

```typescript
---
    // Javascript server code 
---
    // HTML template
```
and the component will look like this :

```typescript
---
 // imports  ...
    const userName = await getUserNameFromServer()
---
    <h1>Hello {userName}!</h1>
```

Second, this component forever will run on the server, and cannot be configuerd to run on the client. 
If you want a client component, you have to use a different model (React, Solid, Preact etc). 
If you want to cahnge the environemnt the component runs on, you need to create a new component. 

### Remember Streaming?
Server Components have a cool benefit, they allow you to split the rendering work into chunks and stream them to the client as they become ready. Cool right?
Accually astro components have it already. Astros SSR uses HTML streaming to send each component to the browser when available for faster page loading [look here](https://docs.astro.build/en/recipes/streaming-improve-page-performance/).
That means that only by spliting your components you can steam each chunk to the client when it is ready. 
As for today Astro does not give a native way to suspense async compoments, however there is a [small package by ben holmes](https://simple-stack.dev/stream) 
Quick note - using this package in the `astro.config.mjs` will break view transitions for some reason. I hope this will be fixed soon.


### More streaming - partial pre rendering
NextJs 14 has just announsed their new feuture [Partial Prerendering ](https://vercel.com/blog/partial-prerendering-with-next-js-creating-a-new-default-rendering-model) (as experimental). 
Partial Prerendering allows static portions of a route to be prerendered and served from the cache with dynamic holes streamed in, 
all in a single HTTP request. This is very cool and I was surprised to see that Astro does not supprot this kind of behavior.
In astro you can only prerender the whole page, and if you want to stream in some parts of the page, you have to configure that page to be SSR,
however I am sure after NextJs has announsed this feuture, Astro will have to support it as well soon. I opend  a discussion on the [Astro Project Roadmap ](https://github.com/withastro/roadmap/discussions/852) 


### Bounos - Client compoments
We talked about server components, but as a bounos lets talk a little bit about client components. In React (and nextjs) in order to create a client component you need to use
the `'use client'` directive. This is cool but a littel restrictive, because what if I want this client component to be ship to the client only when it is visible to the user? 
In Astro you can use [Client Directives](https://docs.astro.build/en/reference/directives-reference/#client-directives). You can use for example `client:visible`. 
which is useful for low-priority UI elements that are either far down the page. This directive load and hydrate the component JavaScript once the component has entered the users viewport.


For example: 

```typescript
---
    // imports  ...
    // Javascript server code
---
  <BlogInteractionManager id={id} blogData={blogData} client:visible />


```

### Conclusion
In this article we compared React Server Components with Astro Components.
We talk about a few things: 
1. Both have the same benefits, but Astro components have a clearer model and are less error prone in my opinion (HTML vs RSC payload).
2. Astro components have a streaming model and that they are SSR all the way.
3. Astro components have a different model for server and client components, and that they have a client directives which gives you more control over when the client component is loaded.
4. Astro components do not support partial prerendering, but I am sure they will have to support it soon after NextJs has announsed this feuture.
