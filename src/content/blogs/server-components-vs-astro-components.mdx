---
id: '683d7f38-dcb5-4259-aceb-3493bd85f9d5'
author: Asaf Naory
title: "React Server Component vs Astro Components"
tags: ['react', 'next', 'astro']
date: February 27 2024
image: '../assets/astro-blog.png'
authorImage: '../assets/AsafNaory2.png'
---

React Server Components (RSC) represent an emerging trend in the React ecosystem. If you're already familiar with RSC, you understand their significance. 
For those less familiar, I recommend exploring the [NextJs documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components) for a deeper understanding.

RSCs are crafted using React. The data streamed to the client isn't traditional HTML but rather a unique format known as React Server Component Payload. 
This format includes the components, placeholders for where [Client Components](https://nextjs.org/docs/app/building-your-application/rendering/client-components) are to be rendered, and any properties sent from the server.

Consider the following example, which illustrates the complexity of the React Server Component Payload:

```
3:I[7151,[],""]
4:I[7173,[],""]
0:["3C9wdBOqSjd8Hs2tA4aLQ",[[["",{"children":["route1",{"children":["__PAGE__",{}]}]},"$undefined","$undefined",true],["",{"children":["route1",{"children":["__PAGE__",{},[["$L1","$L2"],null]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","route1","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__className_aaf875","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}]}]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/b24e6923321a8480.css","precedence":"next","crossOrigin":""}]],"$L5"]]]]
6:"$Sreact.suspense"
8:"$Sreact.fragment"
2:[["$","h1",null,{"children":"Some Static Template Start!!"}],["$","$6",null,{"fallback":["$","h1",null,{"children":"Loading..."}],"children":"$L7"}],["$","h1",null,{"children":"Some Static Template End!!"}]]
9:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Create Next App"}],["$","meta","3",{"name":"description","content":"Generated by create next app"}],["$","link","4",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","meta","5",{"name":"next-size-adjust"}]]
5:["$","$8","O56IjCjabCi9_67Qnm6U3",{"children":"$9"}]
1:null
7:P

```


In contrast, Astro components offer a simpler approach. They are HTML-only templating components without a client-side runtime. According to the Astro website, they leverage good old HTML, enhanced with some additional features.

This article aims to compare RSC with Astro Components to determine any advantages one might have over the other.


### React Server Components vs. Server-Side Rendering (SSR)
There's a common misconception that RSC and SSR are entirely different, yet they share several benefits. For instance, both approaches allow moving data fetching to the server, closer to the data source. The key difference lies in streaming capabilities, which we'll discuss shortly.

However, why differentiate RSC from SSR if their benefits overlap? The distinction becomes clearer when considering metaframeworks like NextJs or Remix, where RSC and SSR serve different purposes:

SSR occurs only during the initial page load, whereas RSC operates throughout the app's lifespan.
SSR delivers HTML, whereas RSC returns the React Server Component Payload.
Despite these differences, server-side rendering fundamentally means processing code on the server, regardless of the output format or timing.


### Astro Components: A Clearer and Less Error-Prone Model
Astro components appeal to me for their clarity and reduced potential for errors. They share several benefits with RSC, 
such as efficient data fetching and minimal bundle sizes, yet the differences are notable.

But the model is cleaer, for two reasons:

#### 1. HTML, Only HTML and nothing but HTML

Astro components deliver HTML to the client, not the React Server Component Payload. 
This simpler model aligns with the webs foundational technology, HTML. 
The explicit nature of Astro's output makes diagnosing issues more straightforward compared to the complexity of RSC payloads. 
Additionally, as an MPA (Multi-Page Application), Astro maintains this straightforward SSR model across navigations.

Now you may think what about hard refresh between routes? 
This is not to purpose of this blog post, but take a look at astro [view transitions](https://docs.astro.build/en/guides/view-transitions/).

#### 2. Distinct Models for Server and Client Environments
Astros delineation between server and client components prevents the common pitfalls associated with using a single model for both environments.
Consider the transformation of a simple component into a client-side component due to a misunderstanding of the model.
Astro's clear separation mitigates this risk, ensuring server components remain server-side.

For example, consider the following component:

```typescript
    const displayHello = () => {
        <h1>Hello user!</h1>
    }
```
which will display very simple string on the screen. 

Lets say for example that after a few weeks there is a request to change it to display the `user name`.

The developer can make this change:

```typescript
    'use client'
    // imports  ...

    const displayHello = () => {
        const [userName, setUserName ] = useState()
        useEffect(()=>{
            async function setUserToState() {
                const userName = await getUserNameFromServer() // http request...
                setUserName(userName)
            }
            await setUserToState()
        });

        <h1>Hello {userName}!</h1>
    }
```
This might look like a lot of code to you, but for someone who does not know the new model, this might be a quick solution. I have seen a lot of bad code in my life, 
I totaly think it can happen. Now this component if forever be a client component for no good reason. 


The fact that astro has a different model for components that run on the server and cannot be configuerd to run on the client is a benefit in my opinion.
First, the model is very easy:


for example: 

```typescript
---
    // Javascript server code 
---
    // HTML template
```
and the component will look like this :

```typescript
---
 // imports  ...
    const userName = await getUserNameFromServer()
---
    <h1>Hello {userName}!</h1>
```

Second, this component forever will run on the server, and cannot be configuerd to run on the client. 
If you want a client component, you have to use a different model (React, Solid, Preact etc). 
If you want to cahnge the environemnt the component runs on, you need to create a new component. 


Remember Streaming?
Server Components offer a unique advantage: they allow you to divide the rendering process into chunks and stream these to the client as they're ready. 
Pretty cool, right? Interestingly, Astro components already feature this capability. 
Astros Server-Side Rendering (SSR) employs HTML streaming to deliver each component to the browser as soon as it becomes available, enhancing page load speed. You can find more about this [here](https://docs.astro.build/en/recipes/streaming-improve-page-performance/).
This means that by merely splitting your components, you can stream each piece to the client upon readiness. Currently, Astro lacks a built-in method for suspending asynchronous components. However, there is a small package by [Ben Holmes](https://simple-stack.dev/stream)  that provides this functionality. A quick note: using this package in the astro.config.mjs file may disrupt view transitions for some reason.
It's hoped that this issue will be resolved soon.

### More Streaming - Partial Pre-rendering

Next.js 14 has just announced their new feature, [Partial Pre-rendering](https://vercel.com/blog/partial-prerendering-with-next-js-creating-a-new-default-rendering-model) (currently experimental). 
This approach allows static portions of a route to be pre-rendered and served from the cache, with dynamic content "holes" streamed in â€” all within a single HTTP request. 
This capability is quite exciting, and it was surprising to discover that Astro does not support this behavior yet. 
In Astro, you can only pre-render an entire page. If you wish to stream parts of a page, you must configure that page for Server-Side Rendering (SSR).
However, following Next.js's announcement of this feature, it's likely that Astro will soon adopt a similar approach.
I have initiated a discussion on the [Astro Project Roadmap](https://github.com/withastro/roadmap/discussions/852) regarding this.


### Bonus - Client Components

While we have discussed server components, lets delve into client components as a bonus. In React (and Next.js), creating a client component requires the `'use client'` directive. 
Although useful, this approach can be somewhat limiting. For instance, what if you want the client component to only be sent to the client when it becomes visible to the user? Astro provides a solution through its [Client Directives](https://docs.astro.build/en/reference/directives-reference/#client-directives). 
One such example is `client:visible`, particularly beneficial for low-priority UI elements positioned further down the page. 
This directive ensures the components JavaScript is loaded and hydrated once the component enters the users viewport.


For example: 

```typescript
---
    // imports  ...
    // Javascript server code
---
  <BlogInteractionManager id={id} blogData={blogData} client:visible />


```

### Conclusion
Comparing React Server Components with Astro Components reveals that while both share common benefits, 
Astros approach provides a clearer, simpler, and less error-prone model. 
The differences in streaming capabilities, model clarity, and client component management highlight the unique advantages of each framework.
As the web development landscape evolves, it is crucial to consider these aspects when choosing between React and Astro for your projects.

